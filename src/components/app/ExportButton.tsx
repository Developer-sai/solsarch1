import { useState } from 'react';
import { Button } from '@/components/ui/button';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu';
import { Download, FileText, FileJson, Loader2, Check } from 'lucide-react';
import { ArchitectureResult, Requirements } from '@/types/architecture';
import { useToast } from '@/hooks/use-toast';
import jsPDF from 'jspdf';

interface ExportButtonProps {
  result: ArchitectureResult;
  requirements: Requirements;
  selectedVariant: number;
}

export const ExportButton = ({ result, requirements, selectedVariant }: ExportButtonProps) => {
  const [isExporting, setIsExporting] = useState(false);
  const [exportSuccess, setExportSuccess] = useState<string | null>(null);
  const { toast } = useToast();

  const generatePDF = async () => {
    setIsExporting(true);
    
    try {
      const pdf = new jsPDF();
      const arch = result.architectures[selectedVariant];
      let yPos = 20;
      const margin = 20;
      const pageWidth = pdf.internal.pageSize.getWidth();

      // Helper function for adding text with word wrap
      const addText = (text: string, fontSize: number, isBold = false, color = '#000000') => {
        pdf.setFontSize(fontSize);
        pdf.setFont('helvetica', isBold ? 'bold' : 'normal');
        pdf.setTextColor(color);
        const lines = pdf.splitTextToSize(text, pageWidth - margin * 2);
        pdf.text(lines, margin, yPos);
        yPos += lines.length * (fontSize * 0.5) + 4;
      };

      const addSection = (title: string) => {
        if (yPos > 250) {
          pdf.addPage();
          yPos = 20;
        }
        yPos += 8;
        addText(title, 14, true, '#6366f1');
        yPos += 2;
      };

      // Header
      pdf.setFillColor(99, 102, 241);
      pdf.rect(0, 0, pageWidth, 40, 'F');
      pdf.setTextColor('#ffffff');
      pdf.setFontSize(24);
      pdf.setFont('helvetica', 'bold');
      pdf.text('SolsArch Architecture Report', margin, 25);
      pdf.setFontSize(10);
      pdf.setFont('helvetica', 'normal');
      pdf.text(`Generated: ${new Date().toLocaleDateString()}`, margin, 35);
      
      yPos = 55;

      // Requirements Summary
      addSection('Requirements Summary');
      addText(`Application Type: ${requirements.appType}`, 10);
      addText(`Expected Users: ${requirements.expectedUsers.toLocaleString()}`, 10);
      addText(`Requests/Second: ${requirements.requestsPerSecond}`, 10);
      addText(`Data Size: ${requirements.dataSizeGB} GB`, 10);
      addText(`Latency Target: ${requirements.latencyTargetMs}ms`, 10);
      addText(`Availability SLA: ${requirements.availabilitySLA}%`, 10);
      addText(`Regions: ${requirements.regions.join(', ')}`, 10);
      addText(`Budget: $${requirements.budgetMin} - $${requirements.budgetMax}/month`, 10);

      // Selected Architecture
      addSection(`Selected Architecture: ${arch.name}`);
      addText(arch.description, 10);

      // Components
      addSection('Architecture Components');
      arch.components.forEach(comp => {
        addText(`• ${comp.name} (${comp.serviceType})`, 10);
        if (comp.providers) {
          const providerDetails = Object.entries(comp.providers)
            .map(([p, d]) => `${p.toUpperCase()}: ${d.service} - $${d.monthlyCost}/mo`)
            .join(', ');
          addText(`  ${providerDetails}`, 9, false, '#666666');
        }
      });

      // Cost Comparison
      addSection('Cost Comparison');
      Object.entries(arch.totalCosts).forEach(([provider, cost]) => {
        addText(`${provider.toUpperCase()}: $${cost.toLocaleString()}/month`, 10);
      });
      
      const minCost = Math.min(...Object.values(arch.totalCosts));
      const cheapestProvider = Object.entries(arch.totalCosts).find(([, c]) => c === minCost)?.[0];
      addText(`Recommended: ${cheapestProvider?.toUpperCase()} (lowest cost)`, 10, true, '#10b981');

      // Assumptions
      addSection('Assumptions');
      arch.assumptions.forEach(assumption => {
        addText(`• ${assumption}`, 10);
      });

      // Trade-offs
      addSection('Trade-offs');
      arch.tradeOffs.forEach(tradeoff => {
        addText(`• ${tradeoff}`, 10);
      });

      // Recommendations
      if (result.recommendations.length > 0) {
        addSection('Optimization Recommendations');
        result.recommendations.forEach(rec => {
          addText(`[${rec.priority.toUpperCase()}] ${rec.title}`, 10, true);
          addText(rec.description, 9);
          if (rec.impactPercentage) {
            addText(`Potential savings: ${rec.impactPercentage}%`, 9, false, '#10b981');
          }
          yPos += 4;
        });
      }

      // Footer
      pdf.setFontSize(8);
      pdf.setTextColor('#999999');
      pdf.text('Generated by SolsArch - AI Solutions Architect', margin, pdf.internal.pageSize.getHeight() - 10);

      // Save PDF
      pdf.save(`solsarch-architecture-${arch.variant}-${Date.now()}.pdf`);
      
      setExportSuccess('pdf');
      setTimeout(() => setExportSuccess(null), 2000);
      
      toast({
        title: "PDF Exported",
        description: "Architecture report downloaded successfully.",
      });
    } catch (error) {
      console.error('PDF export error:', error);
      toast({
        title: "Export Failed",
        description: "Failed to generate PDF. Please try again.",
        variant: "destructive",
      });
    } finally {
      setIsExporting(false);
    }
  };

  const exportJSON = () => {
    const data = {
      generatedAt: new Date().toISOString(),
      requirements,
      selectedArchitecture: result.architectures[selectedVariant],
      allArchitectures: result.architectures,
      recommendations: result.recommendations,
    };

    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `solsarch-export-${Date.now()}.json`;
    a.click();
    URL.revokeObjectURL(url);

    setExportSuccess('json');
    setTimeout(() => setExportSuccess(null), 2000);

    toast({
      title: "JSON Exported",
      description: "Architecture data downloaded successfully.",
    });
  };

  const exportMarkdown = () => {
    const arch = result.architectures[selectedVariant];
    const minCost = Math.min(...Object.values(arch.totalCosts));
    const cheapestProvider = Object.entries(arch.totalCosts).find(([, c]) => c === minCost)?.[0];

    let md = `# SolsArch Architecture Report\n\n`;
    md += `_Generated: ${new Date().toLocaleDateString()}_\n\n`;
    
    md += `## Requirements\n\n`;
    md += `| Property | Value |\n|----------|-------|\n`;
    md += `| App Type | ${requirements.appType} |\n`;
    md += `| Expected Users | ${requirements.expectedUsers.toLocaleString()} |\n`;
    md += `| Requests/Second | ${requirements.requestsPerSecond} |\n`;
    md += `| Data Size | ${requirements.dataSizeGB} GB |\n`;
    md += `| Latency Target | ${requirements.latencyTargetMs}ms |\n`;
    md += `| Availability | ${requirements.availabilitySLA}% |\n`;
    md += `| Regions | ${requirements.regions.join(', ')} |\n`;
    md += `| Budget | $${requirements.budgetMin} - $${requirements.budgetMax}/mo |\n\n`;

    md += `## ${arch.name}\n\n`;
    md += `${arch.description}\n\n`;

    md += `### Components\n\n`;
    arch.components.forEach(comp => {
      md += `- **${comp.name}** (${comp.serviceType})\n`;
    });
    md += `\n`;

    md += `### Cost Comparison\n\n`;
    md += `| Provider | Monthly Cost |\n|----------|-------------|\n`;
    Object.entries(arch.totalCosts).forEach(([provider, cost]) => {
      const isCheapest = provider === cheapestProvider;
      md += `| ${provider.toUpperCase()} | $${cost.toLocaleString()} ${isCheapest ? '✅' : ''} |\n`;
    });
    md += `\n`;

    md += `### Assumptions\n\n`;
    arch.assumptions.forEach(a => md += `- ${a}\n`);
    md += `\n`;

    md += `### Trade-offs\n\n`;
    arch.tradeOffs.forEach(t => md += `- ${t}\n`);
    md += `\n`;

    if (result.recommendations.length > 0) {
      md += `## Recommendations\n\n`;
      result.recommendations.forEach(rec => {
        md += `### ${rec.title}\n`;
        md += `**Priority:** ${rec.priority} | **Potential Savings:** ${rec.impactPercentage}%\n\n`;
        md += `${rec.description}\n\n`;
      });
    }

    md += `---\n_Generated by SolsArch - AI Solutions Architect_\n`;

    const blob = new Blob([md], { type: 'text/markdown' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `solsarch-architecture-${arch.variant}.md`;
    a.click();
    URL.revokeObjectURL(url);

    setExportSuccess('md');
    setTimeout(() => setExportSuccess(null), 2000);

    toast({
      title: "Markdown Exported",
      description: "Architecture document downloaded successfully.",
    });
  };

  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button variant="outline" className="gap-2" disabled={isExporting}>
          {isExporting ? (
            <Loader2 className="w-4 h-4 animate-spin" />
          ) : (
            <Download className="w-4 h-4" />
          )}
          Export
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent align="end">
        <DropdownMenuItem onClick={generatePDF} className="gap-2">
          <FileText className="w-4 h-4" />
          Export as PDF
          {exportSuccess === 'pdf' && <Check className="w-4 h-4 text-success ml-auto" />}
        </DropdownMenuItem>
        <DropdownMenuItem onClick={exportMarkdown} className="gap-2">
          <FileText className="w-4 h-4" />
          Export as Markdown
          {exportSuccess === 'md' && <Check className="w-4 h-4 text-success ml-auto" />}
        </DropdownMenuItem>
        <DropdownMenuItem onClick={exportJSON} className="gap-2">
          <FileJson className="w-4 h-4" />
          Export as JSON
          {exportSuccess === 'json' && <Check className="w-4 h-4 text-success ml-auto" />}
        </DropdownMenuItem>
      </DropdownMenuContent>
    </DropdownMenu>
  );
};
